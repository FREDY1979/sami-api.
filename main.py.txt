# main.py

from fastapi import FastAPI
import pandas as pd
from pydantic import BaseModel
import numpy as np

# --- 1. Configuraci√≥n de la API para Auditor√≠a y Consulta ---

app = FastAPI(
    title="API de Auditor√≠a y Consulta para CODEX JARVIS",
    description="""
    Endpoint robusto dise√±ado para la **extracci√≥n exhaustiva de datos**.
    Recibe una consulta cl√≠nica, la procesa contra la Matriz de Datos Cl√≠nicos y,
    utilizando una **vinculaci√≥n de doble clave (ITEM ID + C√≥digo ADN)**, extrae
    y consolida la totalidad de los datos de la Matriz de Medidas Funcionales.
    Ideal para auditor√≠as, consultas y flujos de trabajo en n8n.
    """,
    version="4.0 - Auditor"
)

# --- 2. Carga Segura y Consistente de las Bases de Datos ---

# Se definen los tipos de datos para las columnas clave para garantizar una
# coincidencia perfecta y evitar errores de tipo (ej. 123 vs "123").
column_types = {
    'ITEM ID  DE  LA MATRIZ': str,
    'C√≥digo ADN Cl√≠nico-Funcional': str
}

try:
    # Carga la matriz de datos cl√≠nicos, asegurando la consistencia de tipos.
    df_clinico = pd.read_csv(
        "CODEX JARVIS - MATRIZ DE DATOS CL√çNICO - FUNCIONALES.xlsx - Hoja1.csv",
        dtype=column_types
    )
    df_clinico.columns = df_clinico.columns.str.strip()
    print("‚úÖ Base de Datos Cl√≠nica cargada y lista para auditor√≠a.")

    # Carga la matriz de medidas funcionales, asegurando la consistencia de tipos.
    df_medidas = pd.read_csv(
        "CODEX JARVIS - MATRIZ DE MEDIDAS FUNCIONALES.xlsx - Hoja1.csv",
        dtype=column_types
    )
    df_medidas.columns = df_medidas.columns.str.strip()
    print("‚úÖ Base de Datos de Medidas Funcionales cargada y lista para auditor√≠a.")

except FileNotFoundError as e:
    print(f"‚ùå ERROR CR√çTICO AL INICIAR: Archivo no encontrado: {e.filename}")
    df_clinico = None
    df_medidas = None
except Exception as e:
    print(f"‚ùå ERROR INESPERADO AL CARGAR ARCHIVOS: {e}")
    df_clinico = None
    df_medidas = None

# Define la estructura de la consulta que la API recibir√°
class Consulta(BaseModel):
    texto_de_la_consulta: str


# --- 3. L√≥gica de Inferencia y Extracci√≥n Exhaustiva ---

def auditar_consulta(query: str):
    """
    Motor principal de la API. Ejecuta el protocolo de auditor√≠a:
    1.  Busca en la matriz cl√≠nica (Columnas K y L) para encontrar el registro √∫nico.
    2.  Extrae las dos llaves maestras: ITEM ID y C√≥digo ADN.
    3.  Usa AMBAS llaves para una b√∫squeda de alta precisi√≥n en la matriz de medidas.
    4.  Si la vinculaci√≥n es exitosa, extrae y devuelve **TODOS los campos** de ambas filas.
    """
    if df_clinico is None or df_medidas is None:
        return {"error": "Bases de datos no disponibles. Contacte al administrador."}

    # B√∫squeda inicial en las columnas primarias del n√∫cleo cl√≠nico
    col_k = "CONDICI√ìN CL√çNICA M√âDICA"
    col_l = "HALLAZGO ESPERADO"

    mask = (df_clinico[col_k].str.contains(query, case=False, na=False)) | \
           (df_clinico[col_l].str.contains(query, case=False, na=False))
    
    resultados_df = df_clinico[mask]

    # --- Evaluaci√≥n de Resultados ---
    if len(resultados_df) == 0:
        return {"error": f"Auditor√≠a fallida. Cero registros encontrados para la consulta: '{query}'."}

    if len(resultados_df) > 1:
        return {"error": f"Ambig√ºedad detectada. La consulta arroj√≥ {len(resultados_df)} resultados. Se requiere mayor especificidad para una auditor√≠a precisa."}

    # --- √âxito: Registro √önico Localizado. Procediendo a la extracci√≥n completa ---
    if len(resultados_df) == 1:
        print(f"üéØ Registro √∫nico localizado para '{query}'. Iniciando extracci√≥n de datos completa...")
        
        # Convierte la fila cl√≠nica a un diccionario, manejando valores nulos.
        resultado_clinico_series = resultados_df.iloc[0].replace({np.nan: None})
        datos_clinicos_completos = resultado_clinico_series.to_dict()
        
        # Extrae las dos llaves maestras para la vinculaci√≥n
        item_id = datos_clinicos_completos.get('ITEM ID  DE  LA MATRIZ')
        adn_code = datos_clinicos_completos.get('C√≥digo ADN Cl√≠nico-Funcional')
        
        if not item_id or not adn_code:
            return {"error": "Fallo de integridad de datos. El registro cl√≠nico localizado carece de ITEM ID o C√≥digo ADN."}

        print(f"üß¨ Vinculando con Doble Llave Maestra -> ID: {item_id}, ADN: {adn_code}")

        # --- B√∫squeda de alta precisi√≥n en Matriz de Medidas con la doble llave ---
        mask_medidas = (df_medidas['ITEM ID  DE  LA MATRIZ'] == item_id) & \
                       (df_medidas['C√≥digo ADN Cl√≠nico-Funcional'] == adn_code)
        
        medidas_result_df = df_medidas[mask_medidas]
        
        if len(medidas_result_df) == 0:
             return {
                "advertencia": "Extracci√≥n parcial. Se encontr√≥ el registro cl√≠nico pero su par ID/ADN no existe en la Matriz de Medidas.",
                "datos_clinicos_completos": datos_clinicos_completos,
                "medidas_funcionales_completas": None
            }

        # Convierte la fila de medidas a un diccionario, manejando valores nulos.
        resultado_medidas_series = medidas_result_df.iloc[0].replace({np.nan: None})
        medidas_funcionales_completas = resultado_medidas_series.to_dict()
        print("‚úÖ ¬°Extracci√≥n completa y vinculaci√≥n exitosa!")

        # --- Ensamblaje del Informe Final de Auditor√≠a ---
        return {
            "estado_auditoria": "Exitosa",
            "consulta_realizada": query,
            "datos_clinicos_completos": datos_clinicos_completos,
            "medidas_funcionales_completas": medidas_funcionales_completas
        }
    
    return {"error": "Error desconocido durante el proceso de auditor√≠a."}


# --- 4. El Endpoint de la API: La Puerta de Entrada para n8n ---

@app.post("/auditar")
def procesar_auditoria(consulta: Consulta):
    """
    Recibe una consulta textual desde un cliente (n8n, etc.),
    la procesa con el motor de auditor√≠a de SAMI y devuelve
    el conjunto de datos completo y consolidado.
    """
    query_texto = consulta.texto_de_la_consulta
    resultado_final = auditar_consulta(query_texto)
    return resultado_final

